<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Record Audio - Voice Dataset Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="{{ url_for('static', path='css/style.css') }}" rel="stylesheet">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="/">
                <i class="fas fa-microphone me-2"></i>Voice Dataset Manager
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Dashboard</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="/record">Record</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/profiles">Profiles</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <div class="row">
            <div class="col-12">
                <h1 class="mb-4">Record Audio</h1>
            </div>
        </div>

        <div class="row">
            <div class="col-md-4">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Recording Settings</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="voiceProfile" class="form-label">Voice Profile</label>
                            <select class="form-select" id="voiceProfile" onchange="loadPrompts()">
                                <option value="">Select a profile...</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="promptList" class="form-label">Prompt List</label>
                            <select class="form-select" id="promptList" onchange="loadPromptList()">
                                <option value="">Select a prompt list...</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="autoAdvance" checked>
                                <label class="form-check-label" for="autoAdvance">
                                    Auto-advance after recording
                                </label>
                            </div>
                        </div>

                        <!-- Recording Controls -->
                        <div class="mb-3">
                            <button id="doneRecordingBtn" class="btn btn-primary btn-sm w-100 mb-2" onclick="doneRecording()">
                                <i class="fas fa-check-circle me-1"></i>Done Recording
                            </button>
                            <button id="openFolderBtn" class="btn btn-outline-secondary btn-sm w-100" onclick="openTargetFolder()">
                                <i class="fas fa-folder-open me-1"></i>Open Target Folder
                            </button>
                        </div>
                        <div class="progress mb-3">
                            <div id="recordingProgress" class="progress-bar" role="progressbar" style="width: 0%"></div>
                        </div>
                        <div class="text-center">
                            <span id="progressText">0 / 0 recorded</span>
                        </div>

                        <!-- Recording Statistics -->
                        <div class="mt-3">
                            <h6 class="mb-2">Recording Statistics</h6>
                            <div id="recordingStats">
                                <div class="text-center text-muted">
                                    <i class="fas fa-info-circle me-2"></i>Select a profile to view statistics
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-md-8">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Current Prompt</h5>
                    </div>
                    <div class="card-body">
                        <div id="currentPrompt" class="alert alert-info">
                            <p class="mb-0">Please select a voice profile and prompt list to begin recording.</p>
                        </div>

                        <div class="text-center my-4">
                            <button id="prevButton" class="btn btn-outline-secondary me-2" onclick="previousPrompt()" disabled>
                                <i class="fas fa-backward me-2"></i>Previous
                            </button>
                            <button id="recordButton" class="btn btn-success btn-lg" onclick="toggleRecording()" disabled>
                                <i class="fas fa-microphone me-2"></i>Start Recording
                            </button>
                            <button id="nextButton" class="btn btn-outline-primary ms-2" onclick="nextPrompt()" disabled>
                                <i class="fas fa-forward me-2"></i>Next
                            </button>
                        </div>

                        <div id="recordingStatus" class="alert alert-warning d-none">
                            <i class="fas fa-circle text-danger me-2"></i>Recording in progress...
                        </div>

                        <!-- Input Level Indicator -->
                        <div id="inputLevelContainer" class="d-none mb-3">
                            <label class="form-label">Input Level</label>
                            <div class="progress" style="height: 20px;">
                                <div id="inputLevel" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                            </div>
                            <!-- Clipping Indicator -->
                            <div id="clippingIndicator" class="d-none mt-2">
                                <span class="badge bg-danger">
                                    <i class="fas fa-exclamation-triangle me-1"></i>CLIPPING
                                </span>
                            </div>
                        </div>

                        <!-- Waveform Visualization -->
                        <div id="waveformContainer" class="d-none mb-3">
                            <label class="form-label">Recording Waveform</label>
                            <canvas id="waveformCanvas" class="border rounded w-100" style="max-width: 100%; height: 100px;"></canvas>
                        </div>

                        <div id="audioPlayback" class="mt-3 d-none">
                            <h6>Playback:</h6>
                            <!-- Custom Waveform Player -->
                            <div class="waveform-player">
                                <canvas id="playbackWaveform" class="w-100 border rounded" style="height: 80px; cursor: pointer;"></canvas>
                                <audio id="playbackAudio" style="display: none;" preload="metadata" playsinline webkit-playsinline></audio>
                                <div class="d-flex justify-content-between align-items-center mt-1">
                                    <small class="text-muted" id="playbackTime">0:00 / 0:00</small>
                                    <div>
                                        <button class="btn btn-sm btn-outline-primary me-1" onclick="togglePlayback()" id="playButton">
                                            <i id="playbackIcon" class="fas fa-play"></i>
                                        </button>
                                        <button class="btn btn-sm btn-outline-secondary" onclick="stopPlayback()">
                                            <i class="fas fa-stop"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-2">
                                <button class="btn btn-sm btn-primary" onclick="saveRecording()">
                                    <i class="fas fa-save me-1"></i>Save Recording
                                </button>
                                <button class="btn btn-sm btn-secondary" onclick="discardRecording()">
                                    <i class="fas fa-trash me-1"></i>Discard
                                </button>
                            </div>
                        </div>
                    </div>
                </div>


                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Recording History</h5>
                    </div>
                    <div class="card-body">
                        <div id="recordingHistory" class="list-group">
                            <div class="text-center text-muted">
                                <i class="fas fa-info-circle me-2"></i>No recordings yet
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let currentPromptId = null;
        let currentPromptText = '';
        let currentPromptIndex = 0;
        let allPrompts = [];
        let currentProfileId = '';
        let currentPromptListId = '';
        let recordedPrompts = new Set(); // Track which prompts have been recorded

        // Audio visualization
        let audioContext;
        let analyser;
        let microphone;
        let dataArray;
        let animationId;
        let waveformData = [];
        let clippingCount = 0;
        let isClipping = false;

        // Safari detection
        function isSafari() {
            return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        }

        // Load voice profiles on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadVoiceProfiles();

            // Safari-specific initialization
            if (isSafari()) {
                console.log('Safari detected - enabling compatibility mode');
                // Add Safari-specific CSS or behavior if needed
            }

            // Enable audio context on first user interaction (required by Safari)
            let audioContextEnabled = false;
            function enableAudioContext() {
                if (!audioContextEnabled && audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed');
                        audioContextEnabled = true;
                    });
                }
            }

            // Add click listeners to enable audio context
            document.addEventListener('click', enableAudioContext, { once: true });
            document.addEventListener('touchstart', enableAudioContext, { once: true });
        });

        function loadVoiceProfiles() {
            fetch('/api/profiles')
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('voiceProfile');
                    select.innerHTML = '<option value="">Select a profile...</option>';
                    data.forEach(profile => {
                        const option = document.createElement('option');
                        option.value = profile.id;
                        option.textContent = profile.name;
                        select.appendChild(option);
                    });
                })
                .catch(error => console.error('Error loading profiles:', error));
        }

        function loadRecordingStats() {
            if (!currentProfileId) {
                document.getElementById('recordingStats').innerHTML = `
                    <div class="text-center text-muted">
                        <i class="fas fa-info-circle me-2"></i>Select a profile to view statistics
                    </div>
                `;
                return;
            }

            // Get selected language from prompt list
            const promptListSelect = document.getElementById('promptList');
            let selectedLanguage = null;
            if (promptListSelect.value) {
                const selectedOption = promptListSelect.options[promptListSelect.selectedIndex];
                const text = selectedOption.textContent;
                // Extract language from option text (e.g., "ðŸ‡¸ðŸ‡ª General (550 prompts)")
                if (text.includes('ðŸ‡ºðŸ‡¸')) selectedLanguage = 'en-US';
                else if (text.includes('ðŸ‡¬ðŸ‡§')) selectedLanguage = 'en-GB';
                else if (text.includes('ðŸ‡¸ðŸ‡ª')) selectedLanguage = 'sv-SE';
                else if (text.includes('ðŸ‡®ðŸ‡¹')) selectedLanguage = 'it-IT';
            }

            const url = selectedLanguage ?
                `/api/recording_stats/${currentProfileId}?selected_language=${selectedLanguage}` :
                `/api/recording_stats/${currentProfileId}`;

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    displayRecordingStats(data);
                })
                .catch(error => console.error('Error loading recording stats:', error));
        }

        function displayRecordingStats(stats) {
            const statsContainer = document.getElementById('recordingStats');

            if (stats.length === 0) {
                statsContainer.innerHTML = `
                    <div class="text-center text-muted">
                        <i class="fas fa-info-circle me-2"></i>No recordings found
                    </div>
                `;
                return;
            }

            let html = '';
            stats.forEach(stat => {
                const language = stat.language_code.startsWith('en-US') ? 'ðŸ‡ºðŸ‡¸' :
                               stat.language_code.startsWith('en-GB') ? 'ðŸ‡¬ðŸ‡§' :
                               stat.language_code.startsWith('sv-SE') ? 'ðŸ‡¸ðŸ‡ª' :
                               stat.language_code.startsWith('it-IT') ? 'ðŸ‡®ðŸ‡¹' : '';

                const category = stat.prompt_list.includes('General') ? 'General' :
                               stat.prompt_list.includes('Chat') ? 'Chat' :
                               stat.prompt_list.includes('CustomerService') ? 'Customer Service' : stat.prompt_list;

                const percentage = stat.total > 0 ? Math.round((stat.recorded / stat.total) * 100) : 0;

                html += `
                    <div class="mb-2">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="small">${language} ${category}</span>
                            <span class="small text-muted">${stat.recorded}/${stat.total}</span>
                        </div>
                        <div class="progress" style="height: 6px;">
                            <div class="progress-bar" role="progressbar" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            });

            statsContainer.innerHTML = html;
        }

        function loadPrompts() {
            const profileId = document.getElementById('voiceProfile').value;
            if (!profileId) {
                document.getElementById('promptList').innerHTML = '<option value="">Select a prompt list...</option>';
                return;
            }

            fetch(`/api/profiles/${profileId}/prompts`)
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('promptList');
                    select.innerHTML = '<option value="">Select a prompt list...</option>';
                    data.forEach(prompt => {
                        const option = document.createElement('option');
                        option.value = prompt.id;
                        // Show language and prompt count in the dropdown
                        const language = prompt.name.startsWith('en-US_') ? 'ðŸ‡ºðŸ‡¸' :
                                       prompt.name.startsWith('en-GB_') ? 'ðŸ‡¬ðŸ‡§' :
                                       prompt.name.startsWith('sv-SE_') ? 'ðŸ‡¸ðŸ‡ª' :
                                       prompt.name.startsWith('it-IT_') ? 'ðŸ‡®ðŸ‡¹' : '';
                        const category = prompt.name.includes('General') ? 'General' :
                                       prompt.name.includes('Chat') ? 'Chat' :
                                       prompt.name.includes('CustomerService') ? 'Customer Service' : '';
                        option.textContent = `${language} ${category} (${prompt.prompt_count} prompts)`;
                        select.appendChild(option);
                    });
                })
                .catch(error => console.error('Error loading prompts:', error));
        }

        function loadPrompts() {
            const profileId = document.getElementById('voiceProfile').value;
            if (!profileId) {
                document.getElementById('promptList').innerHTML = '<option value="">Select a prompt list...</option>';
                return;
            }

            currentProfileId = profileId;
            fetch(`/api/profiles/${profileId}/prompts`)
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('promptList');
                    select.innerHTML = '<option value="">Select a prompt list...</option>';
                    data.forEach(prompt => {
                        const option = document.createElement('option');
                        option.value = prompt.id;
                        // Show language and prompt count in the dropdown
                        const language = prompt.name.startsWith('en-US_') ? 'ðŸ‡ºðŸ‡¸' :
                                       prompt.name.startsWith('en-GB_') ? 'ðŸ‡¬ðŸ‡§' :
                                       prompt.name.startsWith('sv-SE_') ? 'ðŸ‡¸ðŸ‡ª' :
                                       prompt.name.startsWith('it-IT_') ? 'ðŸ‡®ðŸ‡¹' : '';
                        const category = prompt.name.includes('General') ? 'General' :
                                       prompt.name.includes('Chat') ? 'Chat' :
                                       prompt.name.includes('CustomerService') ? 'Customer Service' : '';
                        option.textContent = `${language} ${category} (${prompt.prompt_count} prompts)`;
                        select.appendChild(option);
                    });

                    // Load recording statistics
                    loadRecordingStats();

                    // Load recording history
                    loadRecordingHistory();
                })
                .catch(error => console.error('Error loading prompts:', error));
        }

        function loadPromptList() {
            const promptListId = document.getElementById('promptList').value;
            if (!currentProfileId || !promptListId) {
                document.getElementById('currentPrompt').innerHTML = '<p class="mb-0">Please select a voice profile and prompt list to begin recording.</p>';
                document.getElementById('recordButton').disabled = true;
                document.getElementById('prevButton').disabled = true;
                document.getElementById('nextButton').disabled = true;
                return;
            }

            currentPromptListId = promptListId;
            currentPromptIndex = 0;
            recordedPrompts.clear();

            // Load all prompts for this list
            fetch(`/api/load_prompts/${currentProfileId}/${promptListId}`)
                .then(response => response.json())
                .then(data => {
                    allPrompts = data.prompts;
                    loadCurrentPrompt();
                    loadRecordedStatus();

                    // Refresh stats when prompt list changes
                    loadRecordingStats();
                })
                .catch(error => console.error('Error loading prompt list:', error));
        }

        function loadCurrentPrompt() {
            if (allPrompts.length === 0) {
                document.getElementById('currentPrompt').innerHTML = '<p class="mb-0">No prompts available!</p>';
                document.getElementById('recordButton').disabled = true;
                document.getElementById('prevButton').disabled = true;
                document.getElementById('nextButton').disabled = true;
                return;
            }

            const prompt = allPrompts[currentPromptIndex];
            currentPromptId = currentPromptIndex + 1;
            currentPromptText = prompt;

            document.getElementById('currentPrompt').innerHTML = `
                <h6>Prompt #${currentPromptId} of ${allPrompts.length}</h6>
                <p class="mb-0 fs-5">${currentPromptText}</p>
                <div class="mt-2">
                    <span class="badge ${recordedPrompts.has(currentPromptIndex) ? 'bg-success' : 'bg-secondary'}">
                        ${recordedPrompts.has(currentPromptIndex) ? 'âœ“ Recorded' : 'Not recorded'}
                    </span>
                </div>
            `;

            document.getElementById('recordButton').disabled = false;
            document.getElementById('prevButton').disabled = currentPromptIndex === 0;
            document.getElementById('nextButton').disabled = currentPromptIndex === allPrompts.length - 1;

            // Check if this prompt has a recording and show playback if it does
            if (recordedPrompts.has(currentPromptIndex)) {
                loadExistingRecording(currentPromptIndex);
            } else {
                document.getElementById('audioPlayback').classList.add('d-none');
            }

            updateProgress();
        }

        function nextPrompt() {
            if (currentPromptIndex < allPrompts.length - 1) {
                currentPromptIndex++;
                loadCurrentPrompt();
            }
        }

        function previousPrompt() {
            if (currentPromptIndex > 0) {
                currentPromptIndex--;
                loadCurrentPrompt();
            }
        }

        function loadRecordedStatus() {
            // Load which prompts have been recorded for this profile/prompt list
            fetch(`/api/recorded_status/${currentProfileId}/${currentPromptListId}`)
                .then(response => response.json())
                .then(data => {
                    recordedPrompts = new Set(data.recorded_indices || []);
                    loadCurrentPrompt(); // Refresh display
                })
                .catch(error => console.error('Error loading recorded status:', error));
        }

        function updateProgress() {
            const recorded = recordedPrompts.size;
            const total = allPrompts.length;
            const percentage = total > 0 ? (recorded / total) * 100 : 0;
            document.getElementById('recordingProgress').style.width = percentage + '%';
            document.getElementById('progressText').textContent = `${recorded} / ${total} recorded`;
        }

        async function toggleRecording() {
            if (!isRecording) {
                await startRecording();
            } else {
                stopRecording();
            }
        }

        async function startRecording() {
            try {
                // Request audio with 44kHz sample rate
                // autoGainControl disabled to prevent over-amplification
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 44100,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: false  // Disabled to match Audacity levels
                    }
                });

                // Prioritize WAV format for better quality, then fallback to other formats
                let mimeType = 'audio/wav';
                const supportedTypes = [
                    'audio/wav',
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/mp4',
                    'audio/mp4;codecs=mp4a.40.2',
                    'audio/ogg;codecs=opus'
                ];

                for (const type of supportedTypes) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        mimeType = type;
                        break;
                    }
                }

                console.log('Browser:', navigator.userAgent);
                console.log('Using MediaRecorder mime type:', mimeType);
                console.log('Safari detected:', isSafari());
                mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
                audioChunks = [];

                // Set isRecording BEFORE setupAudioVisualization
                isRecording = true;

                // Reset clipping counter
                clippingCount = 0;

                // Setup audio visualization
                console.log('Setting up audio visualization with stream:', stream);
                console.log('Stream active:', stream.active);
                console.log('Stream tracks:', stream.getTracks().length);
                setupAudioVisualization(stream);

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    // Use the same mime type that was used for recording
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    document.getElementById('audioPlayback').classList.remove('d-none');
                    document.getElementById('recordingStatus').classList.add('d-none');

                    // Show clipping warning if any clipping occurred
                    if (clippingCount > 0) {
                        showClippingWarning();
                    }

                    // Stop audio visualization
                    stopAudioVisualization();

                    // Draw the waveform for the recorded audio
                    drawPlaybackWaveform(audioBlob);
                };

                mediaRecorder.start();

                document.getElementById('recordButton').innerHTML = '<i class="fas fa-stop me-2"></i>Stop Recording';
                document.getElementById('recordButton').classList.remove('btn-success');
                document.getElementById('recordButton').classList.add('btn-danger');
                document.getElementById('recordingStatus').classList.remove('d-none');
                document.getElementById('audioPlayback').classList.add('d-none');
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Error accessing microphone. Please check permissions.');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;

                document.getElementById('recordButton').innerHTML = '<i class="fas fa-microphone me-2"></i>Start Recording';
                document.getElementById('recordButton').classList.remove('btn-danger');
                document.getElementById('recordButton').classList.add('btn-success');
            }
        }

        function saveRecording() {
            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.wav');
            formData.append('prompt_id', currentPromptId);
            formData.append('prompt_index', currentPromptIndex);
            formData.append('prompt_text', currentPromptText);
            formData.append('profile_id', currentProfileId);
            formData.append('prompt_list_id', currentPromptListId);

            fetch('/api/record', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Mark this prompt as recorded
                    recordedPrompts.add(currentPromptIndex);
                    addToRecordingHistory(currentPromptText, data.duration);
                    document.getElementById('audioPlayback').classList.add('d-none');

                    // Update the current prompt display
                    loadCurrentPrompt();

                    // Refresh recording stats and history
                    loadRecordingStats();
                    loadRecordingHistory();

                    if (document.getElementById('autoAdvance').checked) {
                        nextPrompt();
                    }
                } else {
                    alert('Error saving recording: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error saving recording:', error);
                alert('Error saving recording');
            });
        }

        function discardRecording() {
            document.getElementById('audioPlayback').classList.add('d-none');
            audioChunks = [];
        }

        function skipPrompt() {
            nextPrompt();
        }

        function addToRecordingHistory(promptText, duration) {
            const history = document.getElementById('recordingHistory');
            const item = document.createElement('div');
            item.className = 'list-group-item';
            item.innerHTML = `
                <div class="d-flex w-100 justify-content-between">
                    <h6 class="mb-1">Prompt #${currentPromptId}</h6>
                    <small class="text-muted">${formatDuration(duration)}</small>
                </div>
                <p class="mb-1">${promptText}</p>
            `;

            if (history.querySelector('.text-center')) {
                history.innerHTML = '';
            }
            history.insertBefore(item, history.firstChild);
        }

        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // Audio visualization functions
        function setupAudioVisualization(stream) {
            try {
                // Clean up any existing audio context
                if (audioContext) {
                    audioContext.close();
                }

                // Create new audio context with Safari compatibility
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Safari requires user interaction to resume audio context
                // We'll handle this in the playback function instead
                console.log('Audio context state:', audioContext.state);

                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);

                // Configure analyser for time domain data (waveform)
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;

                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                // Connect microphone to analyser
                microphone.connect(analyser);

                // Ensure containers are visible
                document.getElementById('inputLevelContainer').classList.remove('d-none');
                document.getElementById('waveformContainer').classList.remove('d-none');

                console.log('Audio visualization setup complete');
                console.log('Analyser connected:', analyser !== null);
                console.log('Data array length:', dataArray.length);

                // Test if we can get data
                setTimeout(() => {
                    if (analyser) {
                        analyser.getByteTimeDomainData(dataArray);
                        const testValue = dataArray[0];
                        console.log('Test audio data value:', testValue, '(should be around 128 when silent)');
                    }
                }, 100);

                // Start visualization loop
                drawVisualization();
            } catch (error) {
                console.error('Error setting up audio visualization:', error);
            }
        }

        function drawVisualization() {
            if (!analyser || !isRecording) return;

            // Get time domain data for waveform
            analyser.getByteTimeDomainData(dataArray);

            // Calculate input level from time domain data
            let sum = 0;
            let max = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const value = Math.abs(dataArray[i] - 128); // Center around 0
                sum += value;
                max = Math.max(max, value);
            }
            const average = sum / dataArray.length;
            // Increase sensitivity: multiply by 3 for better visual feedback
            const percentage = Math.min((average / 128) * 300, 100);

            // Debug logging (only log occasionally to avoid spam)
            if (Math.random() < 0.01) { // Log 1% of the time
                console.log('Audio data - Average:', average, 'Max:', max, 'Percentage:', percentage.toFixed(1) + '%');
            }

            // Update input level indicator
            const levelBar = document.getElementById('inputLevel');
            if (levelBar) {
                levelBar.style.width = percentage + '%';

                // Check for clipping (values near maximum)
                // Use 127 (99.2% of max 128) to only warn on actual clipping, not just loud audio
                const clippingThreshold = 127; // Time domain data (0-128 range, 127 = 99.2% of max)
                const wasClipping = isClipping;
                isClipping = max >= clippingThreshold;

                if (isClipping && !wasClipping) {
                    clippingCount++;
                }

                // Color coding for input level and clipping indicator
                if (isClipping) {
                    levelBar.className = 'progress-bar bg-danger';
                    const clippingIndicator = document.getElementById('clippingIndicator');
                    if (clippingIndicator) {
                        clippingIndicator.classList.remove('d-none');
                    }
                } else if (percentage > 50) {
                    levelBar.className = 'progress-bar bg-warning';
                    const clippingIndicator = document.getElementById('clippingIndicator');
                    if (clippingIndicator) {
                        clippingIndicator.classList.add('d-none');
                    }
                } else {
                    levelBar.className = 'progress-bar bg-success';
                    const clippingIndicator = document.getElementById('clippingIndicator');
                    if (clippingIndicator) {
                        clippingIndicator.classList.add('d-none');
                    }
                }
            }

            // Draw waveform
            drawWaveform();

            // Continue animation loop
            if (isRecording) {
                animationId = requestAnimationFrame(drawVisualization);
            }
        }

        function drawWaveform() {
            const canvas = document.getElementById('waveformCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Set canvas size to match display size
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);

            // Draw center line
            ctx.strokeStyle = '#dee2e6';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();

            // Draw waveform bars from time domain data
            const barWidth = Math.max(1, width / dataArray.length);
            const centerY = height / 2;

            for (let i = 0; i < dataArray.length; i++) {
                // Convert time domain data (0-255) to amplitude (-1 to 1)
                const value = (dataArray[i] - 128) / 128;
                const barHeight = Math.abs(value) * height * 0.4; // Half height for better visibility
                const x = i * barWidth;

                // Color based on clipping
                ctx.fillStyle = isClipping ? '#dc3545' : '#007bff';

                // Draw bar from center line
                ctx.fillRect(x, centerY - barHeight / 2, barWidth, barHeight);
            }
        }

        function stopAudioVisualization() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            // Hide visualization elements
            document.getElementById('inputLevelContainer').classList.add('d-none');
            document.getElementById('waveformContainer').classList.add('d-none');
        }

        // Done recording function
        function doneRecording() {
            if (isRecording) {
                alert('Please stop the current recording before finishing.');
                return;
            }

            const recordedCount = recordedPrompts.size;
            const totalCount = allPrompts.length;

            if (recordedCount === 0) {
                if (confirm('You haven\'t recorded any prompts yet. Are you sure you want to finish?')) {
                    returnToMainPage();
                }
            } else {
                const message = `You have recorded ${recordedCount} out of ${totalCount} prompts. Are you sure you want to finish recording?`;
                if (confirm(message)) {
                    returnToMainPage();
                }
            }
        }

        function returnToMainPage() {
            // Clean up any active recordings
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }

            // Stop audio visualization
            stopAudioVisualization();

            // Return to main page
            window.location.href = '/';
        }

        function showClippingWarning() {
            const warning = document.createElement('div');
            warning.className = 'alert alert-warning alert-dismissible fade show mt-2';
            warning.innerHTML = `
                <i class="fas fa-exclamation-triangle me-2"></i>
                Warning: Recording clipped ${clippingCount} times. Consider lowering your input volume.
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            document.getElementById('audioPlayback').appendChild(warning);
        }


        function openTargetFolder() {
            if (!currentProfileId) {
                alert('Please select a profile first.');
                return;
            }

            fetch(`/api/open_recordings_folder/${currentProfileId}`)
                .then(response => response.json())
                .then(data => {
                    if (!data.success) {
                        alert('Error opening folder: ' + data.error);
                    } else if (data.path) {
                        // Running in Docker - show the path
                        alert(`Recordings folder (inside container):\n${data.path}\n\nOn your host machine, check:\nC:\\Users\\Petter\\Desktop\\coaxial-recorder\\voices\\${currentProfileId}\\recordings`);
                    }
                    // If success without path, folder opened successfully
                })
                .catch(error => {
                    console.error('Error opening folder:', error);
                    alert('Error opening folder');
                });
        }

        function loadRecordingHistory() {
            if (!currentProfileId) return;

            fetch(`/api/recording_history/${currentProfileId}?limit=10`)
                .then(response => response.json())
                .then(recordings => {
                    const container = document.getElementById('recordingHistory');
                    container.innerHTML = '';

                    if (recordings.length === 0) {
                        container.innerHTML = `
                            <div class="text-center text-muted">
                                <i class="fas fa-info-circle me-2"></i>No recordings yet
                            </div>
                        `;
                        return;
                    }

                    recordings.forEach(rec => {
                        const item = document.createElement('div');
                        item.className = 'list-group-item';
                        item.innerHTML = `
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h6 class="mb-1">${rec.sentence.substring(0, 50)}${rec.sentence.length > 50 ? '...' : ''}</h6>
                                    <small class="text-muted">${rec.prompt_list}</small>
                                </div>
                                <button class="btn btn-sm btn-outline-primary" onclick="playRecording('${rec.filename}')">
                                    <i class="fas fa-play"></i>
                                </button>
                            </div>
                        `;
                        container.appendChild(item);
                    });
                })
                .catch(error => console.error('Error loading recording history:', error));
        }

        function playRecording(filename) {
            const audio = new Audio(`/api/recording/${currentProfileId}/${filename}`);
            audio.play();
        }

        // Waveform playback variables
        let playbackAudio = null;
        let playbackWaveformData = [];
        let isPlaying = false;
        let playbackAnimationId = null;

        function drawPlaybackWaveform(audioBlob) {
            const canvas = document.getElementById('playbackWaveform');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.offsetWidth;
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);

            // Create audio context for analysis with Safari compatibility
            const analysisAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            const fileReader = new FileReader();

            fileReader.onload = function(e) {
                analysisAudioContext.decodeAudioData(e.target.result).then(audioBuffer => {
                    const channelData = audioBuffer.getChannelData(0);
                    const samplesPerPixel = Math.floor(channelData.length / width);

                    // Generate waveform data
                    playbackWaveformData = [];
                    for (let x = 0; x < width; x++) {
                        const start = x * samplesPerPixel;
                        const end = Math.min(start + samplesPerPixel, channelData.length);
                        let sum = 0;
                        let max = 0;

                        for (let i = start; i < end; i++) {
                            const abs = Math.abs(channelData[i]);
                            sum += abs;
                            max = Math.max(max, abs);
                        }

                        const average = sum / (end - start);
                        playbackWaveformData.push({
                            average: average,
                            max: max,
                            x: x
                        });
                    }

                    // Draw the waveform
                    drawWaveformBars(ctx, width, height, playbackWaveformData, 0);

                    // Set up audio element with Safari compatibility
                    playbackAudio = document.getElementById('playbackAudio');

                    // Create blob URL with proper cleanup
                    if (playbackAudio.src) {
                        URL.revokeObjectURL(playbackAudio.src);
                    }
                    playbackAudio.src = URL.createObjectURL(audioBlob);

                    // Add event listeners
                    playbackAudio.addEventListener('timeupdate', updatePlaybackProgress);
                    playbackAudio.addEventListener('ended', stopPlayback);
                    playbackAudio.addEventListener('error', function(e) {
                        console.error('Audio element error:', e);
                        showPlaybackError();
                    });

                    // Safari-specific: preload the audio and set up proper attributes
                    playbackAudio.load();

                    // Safari-specific attributes for better compatibility
                    if (isSafari()) {
                        playbackAudio.setAttribute('playsinline', 'true');
                        playbackAudio.setAttribute('webkit-playsinline', 'true');
                    }

                    // Add click handler for seeking
                    canvas.addEventListener('click', seekToPosition);

                }).catch(error => {
                    console.error('Error decoding audio for waveform:', error);
                });
            };

            fileReader.readAsArrayBuffer(audioBlob);
        }

        function drawWaveformBars(ctx, width, height, data, progress) {
            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);

            // Draw center line
            ctx.strokeStyle = '#dee2e6';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();

            // Draw waveform bars
            const barWidth = Math.max(1, width / data.length);

            data.forEach((point, index) => {
                const x = point.x;
                const barHeight = point.average * height * 0.8;
                const centerY = height / 2;

                // Color based on progress
                if (x <= progress * width) {
                    ctx.fillStyle = '#007bff'; // Blue for played portion
                } else {
                    ctx.fillStyle = '#6c757d'; // Gray for unplayed portion
                }

                // Draw bar
                ctx.fillRect(x, centerY - barHeight / 2, barWidth, barHeight);
            });
        }

        function togglePlayback() {
            if (!playbackAudio) return;

            if (isPlaying) {
                playbackAudio.pause();
                isPlaying = false;
                document.getElementById('playbackIcon').className = 'fas fa-play';
                if (playbackAnimationId) {
                    cancelAnimationFrame(playbackAnimationId);
                }
            } else {
                // Safari requires user interaction and audio context resume
                playAudioWithSafariSupport();
            }
        }

        async function playAudioWithSafariSupport() {
            try {
                // Resume audio context if suspended (required by Safari)
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // Safari requires explicit play() call with error handling
                const playPromise = playbackAudio.play();

                if (playPromise !== undefined) {
                    await playPromise;
                    isPlaying = true;
                    document.getElementById('playbackIcon').className = 'fas fa-pause';
                    animatePlayback();
                }
            } catch (error) {
                console.error('Audio playback failed:', error);
                // Show user-friendly error message
                showPlaybackError();
            }
        }

        function showPlaybackError() {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'alert alert-warning alert-dismissible fade show mt-2';
            let errorMessage = 'Audio playback failed. ';

            if (isSafari()) {
                errorMessage += 'Safari detected. This may be due to autoplay restrictions or audio format compatibility. ';
                errorMessage += 'Please try clicking the play button again, or check Safari\'s audio settings in Safari > Settings > Websites > Auto-Play.';
            } else {
                errorMessage += 'Please try clicking the play button again or check your browser\'s audio settings.';
            }

            errorDiv.innerHTML = `
                <i class="fas fa-exclamation-triangle me-2"></i>
                ${errorMessage}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            document.getElementById('audioPlayback').appendChild(errorDiv);
        }

        function stopPlayback() {
            if (!playbackAudio) return;

            playbackAudio.pause();
            playbackAudio.currentTime = 0;
            isPlaying = false;
            document.getElementById('playbackIcon').className = 'fas fa-play';

            if (playbackAnimationId) {
                cancelAnimationFrame(playbackAnimationId);
            }

            // Reset waveform display
            const canvas = document.getElementById('playbackWaveform');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            drawWaveformBars(ctx, width, height, playbackWaveformData, 0);

            updatePlaybackTime();
        }

        function animatePlayback() {
            if (!isPlaying || !playbackAudio) return;

            const canvas = document.getElementById('playbackWaveform');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            const progress = playbackAudio.currentTime / playbackAudio.duration;
            drawWaveformBars(ctx, width, height, playbackWaveformData, progress);

            playbackAnimationId = requestAnimationFrame(animatePlayback);
        }

        function updatePlaybackProgress() {
            updatePlaybackTime();
        }

        function updatePlaybackTime() {
            if (!playbackAudio) return;

            const current = formatTime(playbackAudio.currentTime);
            const duration = formatTime(playbackAudio.duration || 0);
            document.getElementById('playbackTime').textContent = `${current} / ${duration}`;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function seekToPosition(event) {
            if (!playbackAudio || !playbackWaveformData.length) return;

            const canvas = document.getElementById('playbackWaveform');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const progress = x / canvas.width;

            playbackAudio.currentTime = progress * playbackAudio.duration;
        }

        function loadExistingRecording(promptIndex) {
            // Find the recording in metadata for this prompt
            fetch(`/api/get_recording_for_prompt/${currentProfileId}/${currentPromptListId}/${promptIndex}`)
                .then(response => response.json())
                .then(data => {
                    if (data.filename) {
                        // Load the audio file and create waveform
                        fetch(`/api/recording/${currentProfileId}/${data.filename}`)
                            .then(response => response.blob())
                            .then(blob => {
                                drawPlaybackWaveform(blob);
                                document.getElementById('audioPlayback').classList.remove('d-none');
                            })
                            .catch(error => console.error('Error loading audio file:', error));
                    }
                })
                .catch(error => console.error('Error loading existing recording:', error));
        }

    </script>

    <!-- Download Prompt List Modal -->
    <div class="modal fade" id="downloadPromptModal" tabindex="-1" aria-labelledby="downloadPromptModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="downloadPromptModalLabel">Download Prompt List</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>This prompt list is not available locally. Would you like to download it?</p>
                    <form id="downloadPromptForm">
                        <div class="mb-3">
                            <label for="downloadSource" class="form-label">Source</label>
                            <select class="form-select" id="downloadSource" name="source">
                                <option value="piper">Piper Recording Studio Wordlists</option>
                                <option value="online">Online LM Dataset</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="downloadLanguage" class="form-label">Language</label>
                            <select class="form-select" id="downloadLanguage" name="language">
                                <option value="en-US">English (US)</option>
                                <option value="en-GB">English (UK)</option>
                                <option value="es-ES">Spanish (Spain)</option>
                                <option value="fr-FR">French (France)</option>
                                <option value="de-DE">German (Germany)</option>
                                <option value="it-IT">Italian (Italy)</option>
                                <option value="pt-BR">Portuguese (Brazil)</option>
                                <option value="ja-JP">Japanese (Japan)</option>
                                <option value="ko-KR">Korean (Korea)</option>
                                <option value="zh-CN">Chinese (Simplified)</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="downloadCategory" class="form-label">Category</label>
                            <select class="form-select" id="downloadCategory" name="category">
                                <option value="General">General</option>
                                <option value="Chat">Chat</option>
                                <option value="CustomerService">Customer Service</option>
                                <option value="Numbers">Numbers</option>
                                <option value="CommonPhrases">Common Phrases</option>
                            </select>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="submit" form="downloadPromptForm" class="btn btn-primary">
                        <i class="fas fa-download me-1"></i>Download
                    </button>
                </div>
            </div>
        </div>
    </div>
</body>
</html>